
########################
Day 17 : 5th August 2025
########################

	- Docker Module ::
	
	- Containerization :
	
		- It is a process of packaging the applications along with its dependencies.
		
	- Virtual Machine :::
	
		- VM is called as a Hardware Level Virtualization 
		- VMs are create using Hyervisor
		- VMs are used to execute Operating System 
		- VMs will be up and running even if there is not active application/task
		- VMs consume more space and time to start-up the service.
	
	- Container :::

		- Container is called as a OS Level Virtualization 
		- Containers are create using Container Engine 
		- Containers are used to execute Application/Task, NOT Operating System
		- Containers will immediately go to exit state if there is no active Application/Task
		- Containers consume less space and time to start-up the service.	
		
		- Container uses the core properties of underlying Operating System
			- Core of OS - Kernel 			
				- Namespaces 
				- Control Groups 
				
			- Container run it is own isolate address space
			
		- Containers can reduce the no. of VMs 
			- We cannot completely elimate VM.
			
	
	- Terminologies ::
	
		- Container Engine 		
					# It is used to create and manage the Container Images and Containers
		
		- Container Image		
					# Container Image is a static file, the defines the properties of application and its dependencies
					# Container Image composed of various layers created using Dockerfile Instructions
					# Container Images are Non-Executable
					
		- Container	
					# Containers are the Executable units of Container Images.					
		
		- Container Registry:
					# Container Registry is used to maintain/Version Control the Container Images 
					# DockerHub is a default Container Registry for Docker Container Engine 
					https://hub.docker.com/
					
					
					Source Code Repo			Artifactory Library 				Container Registry

					github						jfrog/azArtifacts					DockerHub/ACR/ECR
								
					webapp.java_v1.0	==>		webapp.war_snapshot_V1.0	==> 	webapp_img:v1.0
					webapp.java_v1.1	==>		webapp.war_snapshot_V1.1	==>		webapp_img:v1.1
					
		- Container Repositories :
					# Container Repositories are the subset of Container Registry
			
	- Containerization :
	
		- It is a process of packaging the applications along with its dependencies.		

		
	Working with Containers :
	
	
	- Infra-Structure Perspective ::
		
		- Here, Using Container we can reduce the no. of VMs 
		- This we we can reduce the Infra-Structure Cost

		Jenkins_Master (VM)				
											==> Install Git, JDK, Jenkins											
										
			Jenkins_SlaveNode1 (VM1)		==> Java Build Tools					
			Jenkins_SlaveNode1 (VM1.1)		==> Java Build 						
			Jenkins_SlaveNode1 (VM2)		==> Python
			Jenkins_SlaveNode1 (VM3)		==> .Net
			Jenkins_SlaveNode1 (VM4)		==> Angular/Nodejs
			Jenkins_SlaveNode1 (VM5)		==> Ruby
				
		Using Docker :
		
		Jenkins_Master (VM)				
			Jenkins_Build_Server_Node (VM1)
				- Install Container Engine
						Create 	C1			==> Java Build Tools	
								C2          ==> Java Build 		
								C3          ==> Python
								C4          ==> .Net
								C5          ==> Angular/Nodejs
								C6          ==> Ruby
	
	
	- Developers/Deployment Perspective ::

	- Containerization :
	
		- It is a process of packaging the applications along with its dependencies.
		
		Role of Developers :
		
			In Dev Environment :
			
				Create Source Code 
				
				Create Artifacts				mywebapp.war 
					- jdk17, tomcat:8.0

				Unit Testing 
				
					Package the Application : (mywebapp.war,jdk17,tomcat:8.0)	==> Create Application Image : mywebappimg:v1.0
					
					Publish the Image - mywebappimg:v1.0 to Container Registry
				
				Promote the artifacts to Test Environments
				
			
			QA 			
				- pull the Application Image : mywebappimg:v1.0 from Container Registry
				- Create Container out of it.

				
			UAT	
				- pull the Application Image : mywebappimg:v1.0 from Container Registry
				- Create Container out of it. 


			PROD 
				- pull the Application Image : mywebappimg:v1.0 from Container Registry
				- Create Container out of it. 
							
							
							
Next ::

	Working with Docker :
	
		- Install Docker Container Engine 
		- Docker Cli Commands 
	
	
########################
Day 17 : 5th August 2025
########################	
	
	Working with Docker :
	
		- Install Docker Container Engine 
		- Docker Cli Commands 			
		
	Installation of Container Engine :
	
		apt install docker.io -y			# Install Docker Container Engine in Jenkins Slave-Node/Build Server
	
	Docker Cli Commands :	
	
		docker --version
		
		docker images				# List the Images  
		
		docker ps 					# List the Active/running Containers
		
		docker ps -a 				# List all the Container (Active & In-Active)		
		
		Login to DockerHub Console :
		
		Explore the Images!
		
		
		docker pull <image_name>		# To download a latest version of Container Image from DockerHub to Local Machine 
		
		docker pull <image_name>:<tag>	# To download a specific version of Container Image from DockerHub to Local Machine 
		
		docker run <image_name>			# To create a Container based on Container Image 
		
		
		
		Three Modes of Container Execution :
		
		- Foreground/Attached Mode :
		
			docker run <image_name> 
			
			Eg.:
			
				docker run ubuntu sleep 20
		
		- Background/Detached Mode :
		
			docker run -d <image_name> 
			
			Eg.: 
			
				docker run -d ubuntu sleep 20
		
		- Interactive Mode :
		
			docker run -it <image_name>
			
			Eg.: 
			
				docker run -it ubuntu bash
				
				exit							# Exit/stop the Container  
		
		- docker start <Container_ID> 			# Start the Container
		
		- Login to Running Container :
		
			docker exec -it <Container_ID> bash 
			
			Eg.:
			
			docker exec -it 092dc9986518 bash
		
			exit 								# Log-off from the Container 
			
		- docker stop <Container_ID> 			# Stop the Running Container 
		
		
		- Port Mapping/Port Binding :::
		
			- It is used to expose the Container Application to Internet.			
			
			docker run -it -p 8085:8080 tomcat:8.0 			
		
				-p <host_port>:<container_port>
			
				Access the Application running inside the container using port mapping :
			
				<external_ip_addr>:<host_port>
				
				43.204.233.96:8085
				
		
		- Remove Containers & Images from Local Machine!
		
			- docker rmi <image_name>			# To Remove Container Images 
			
			- docker rm <Container_ID>			# To Remove Containers 
				
				
		- Docker Volume ::::
		
			- Container are basically used to execute application/task.			
			- Containers are actually used to run the stateless application.
			
			- This is to maintain pesistant data!
			
		3-Tier Application Architecture ????
		
			Sign_in Micro-Service
			
				- Front-End Layer	==> User Interaction 	=> C1 
				
				- Application Layer	==> Business Logic		=> C2 
				
				- Back-End Layer	==> Database 			=> C3 
		
		
Next : 
			Work with Containers 
			Build Images 
			Container Orchestration Tools & Concepts	


		
########################
Day 19 : 8th August 2025
########################		
	
	Docker Volumes :::
	
		- Docker Volume ::::
		
			- Container are basically used to execute application/task.			
			- Containers are actually used to run the stateless application.
			
			- This is to maintain pesistant data!	
			
		Stateless application :
		
			- Application that never retain the state of execution 
		
		Stateful application :
		
			- To work with the stateful applications, Docker Volumes can be used.
			
			
		docker volume list 					# List the Docker Volumes 
		
		docker volume create pl-vol1		# Create a docker volume 
		
		docker volume inspect pl-vol1		# Inpect/Get the Properties of Volume
		
		docker run -it --mount source=pl-vol1,destination=/pl-vol1 ubuntu bash  
	
	
	Create Container Images :::
	
	- docker commit :::
		
		=> To Create a New Container Image based on the properties of existing Container.
		
			Syntax :

				docker commit <existing_container_id> <dockerhub_repo_name>/New_Image_Name>:<tag_Name>
				
				docker commit 83d261074037 loksaieta/pl-mvn-env-img:v1.0

				
	- docker build :::
	
		- To create a new Container Image based on the Dockerfile reference.
		- Dockerfile composed of Instructions to Create Docker Container Images
		- Application Developers create the Dockerfile and update in the Source Code Repository. 
		
			Syntax :
			
			docker build -t <dockerhub_repo_name>/New_Image_Name>:<tag_Name> .		# '.' refers to the Dockerfile path
			
			docker build -t loksaieta/pl-mvn-env-img1 .
			
		vi Dockerfile 
		
			FROM ubuntu 
			RUN apt update -y 
			RUN apt install git -y 
			RUN apt install maven -y
			
			
	- docker push :::
	
		- To Publish the Image to Remote DockerHub Repository.
		
		
		- Access Token : PAT 
		
		
			docker login -u loksaieta
		
			dcasdfsdsdfsdJY
			
			docker push loksaieta/pl-mvn-env-img1
			
			docker push loksaieta/pl-mvn-env-img:v1.0
			
	
	Container Orchestration ::
	
		
	
		- Overview of Docker Compose :::
		
			- Used to execute multiple containers as a Service. 
			- The Container specification will be defined in a manifest file - written using *.yaml script.
			
			- Install and configure docker compose 
				https://docs.docker.com/compose/install/
				
				https://docs.docker.com/compose/install/linux/#install-the-plugin-manually
				

		3-Tier Application Architecture ????
		
			Sign_in Micro-Service		
			
				- Front-End Layer	==> User Interaction 	=> C1 
				
				- Application Layer	==> Business Logic		=> C2 
				
				- Back-End Layer	==> Database 			=> C3 


				- Front-End Layer	==> User Interaction 	=> C1.1,1.2,1.3 
				
				- Application Layer	==> Business Logic		=> C2.1,2.2,2.3
				
				- Back-End Layer	==> Database 			=> C3.1,3.2,3.3

		Work with Docker Compose ::
		
			Install Docker_Compose
			
			https://docs.docker.com/compose/install/linux/
			
# Manual Installation of Docker Compose :::
			
DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
mkdir -p $DOCKER_CONFIG/cli-plugins
curl -SL https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose

chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
	
docker compose version

vi docker-compose.yaml



### Yaml Files are based on Keys & Values -- key:value Pairs

version: '3'
services:
  webserv1:
    image: "tomcat:8.0"
    ports:
      - 8098:8080
  dbserv1:
    image: "redis:alpine"
	
docker compose up 

docker compose down 

				
		- Overview of Docker Swarm :::
		
			- Docker Swarm is one the Container Orchestration Tools.
			- It is meant only for Docker Containers.
			- Used to Ensure High Availability of Containers by creating Replicas of Containers.
			- We cannot Do Auto-Scaling or Load Balancing!
				
		- Kubernetes!
		
		Docker Container : 
		
		AWS :	ECS/ECR/EKS
		
		Azure : ACS/ACR/AKS
		
		GCP :	GCE/GCR/GKE

		- Kubernetes!
		
			- It is a Open-Source Container Orchestration Tool 
			- Kubernetes is used to Deploy any type of Containers.
			- It is used to ensure high availability of the Applications/services running thru Containers.
			- Used to Ensure High Availability of Containers by creating Replicas of Containers.
			- It supports Auto-Scaling & Load Balancing.		
			
			- App Config file - Manifest file - *.yaml / *.json

#########################
Day 20 : 11th August 2025
#########################		
		
	- Containerization :::
		
		- Docker Build Command to create any Container Image
		
		- Create Dockerfile & maintained in the Source Code Repository
		
	
	- Source Code Repo. URL 
	
	- Create a CICD Pipeline using Jenkins :
	
	- Servers & Tools :
		
		Jenkins_Master 			==> Create CICD Pipeline Projects and Schedule to run in the resp. Agents 
								==> git,jdk,jenkins 
								
			Jenkins_Build_Server_Node	==> Perform Application Build 
										==> git,jdk,maven,docker
	

	- Add devopsadmin user to docker group :
	
		usermod -aG docker devopsadmin


		
	- CICD Pipeline Stages :
	
		Input : 	Source Code Repo. URL 
		
		Output :	Application Artifacts, Application Container Image, Publish to Container Registry.
		
		
		Pipeline :

			- SCM-Checkout
			- Application_Build 			*.war 
			- Application_Image_Build 
			- Publish Application_Image to Container Registry(DockerHub)
			
		Dockerfile :

			FROM ubuntu 
			RUN apt update -y 
			RUN apt install git -y 
			RUN apt install maven -y
					
		
		FROM tomcat:8.0
		COPY ./target/*.war /usr/local/tomcat/webapps
		EXPOSE 8080		
		
		
		Dockerfile Instructions :
		
		FROM 			# This is identify the based Image 
		
		RUN				# To execute any package manager

		COPY 			# To Copy the files from host volume to container volume 
		
		CP				# To Copy the files within the Container Volume 
		
		ADD 			# To Copy/Download the files from external URLs to Container Volume 

		EXPOSE			# To set the Container Port.
		
		WORKDIR			# To Set the Current Working Directory
		
		CMD				# To Set the default Start-up Task to start a Container 
						# The Start-up Task can be Modified at the time of Container Creation 
						
		ENTRYPOINT		# To Set the default Start-up Task to start a Container 
						# The Start-up Task cannot be Modified at the time of Container Creation 						
		


- CICD Pipeline using Docker:

	
pipeline {
    agent { label 'slave1' }

	environment {	
		DOCKERHUB_CREDENTIALS=credentials('dockerloginid')
	}

    stages {
        stage('SCM_Checkout') {
            steps {
                echo 'Perform SCM_Checkout from github repository'
				git 'https://github.com/PL-DevOps-GenAI-0625/java-webapp-project.git'
            }
        }
		
        stage('Application Build') {
            steps {
                echo 'Perform Maven Application Build'
                sh 'mvn clean package'
            }
        }
		
        stage('Build Docker Image') {
            steps {

				sh "docker build -t loksaieta/pl-javawebappimg ."
				
            }
        }
		
		stage('Login2DockerHub') {

			steps {
				sh 'echo $DOCKERHUB_CREDENTIALS_PSW | docker login -u $DOCKERHUB_CREDENTIALS_USR --password-stdin'
			}
		}
		
		stage('Publish_to_Docker_Registry') {
			steps {
				sh "docker push loksaieta/pl-javawebappimg"
			}
		}

    }
}
		

	
